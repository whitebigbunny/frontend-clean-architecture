# Frontend Clean Architecture

Пример приложения, собранного по трёхслойной архитектуре.

- [Слайды и полезные ссылки](https://bespoyasov.ru/talks/podlodka-conf-clean-architecture/);
- [Пример работы приложения](https://bespoyasov.ru/showcase/frontend-clean-architecture/);
- [Запись доклада](https://youtu.be/h4WQRqNjmX0).

## Что учесть

В коде есть несколько компромиссов, о которых я рассказывал в докладе на Frontend Crew. 

### Shared Kernel

Shared Kernel — это тот код и те данные, от которых могут зависеть любые модули, но зависимость от которых не повышает зацепление.

В этом приложении shared kernel включает в себя аннотации типов, которые могут быть доступны где угодно. Такие типы собраны в `shared-kernel.d.ts`.

### «Зависимость» в домене

В функции `createOrder` используется «библиотечная» функция `currentDatetime` для указания даты создания заказа. Это не совсем корректно, потому что домен не должен ни от чего зависеть.

По-хорошему, реализация типа `Order` должна быть классом, аргументами конструктора которого были бы все необходимые данные, включая дату. А создание этого класса находилось бы в прикладном слое в `orderProducts`:

```ts
async function orderProducts(user: User, products: Product[]) {
  const datetime = currentDatetime();
  const order = new Order(user, products, datetime);

  // ...
}
```

### Кустарный DI

В прикладном слое мы «внедряем» сервисы руками:

```ts
export function useAuthenticate() {
  const storage: UserStorageService = useUserStorage();
  const auth: AuthenticationService = useAuth();

  // ...
}
```

По-хорошему, это должно быть автоматизировано и сделано через внедрение зависимостей. В случае с Реактом и хуками мы, в принципе, можем использовать их, как «контейнер», который возвращает реализацию указанного интерфейса.

В конкретно этом приложении настраивать DI особо смысла не было, потому что это бы отвлекало от сути архитектуры.
